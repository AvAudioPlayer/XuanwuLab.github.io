<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>XuanwuLab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="XuanwuLab">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="XuanwuLab">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XuanwuLab">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="XuanwuLab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">XuanwuLab</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Poking-a-Hole-in-the-Patch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/27/Poking-a-Hole-in-the-Patch/" class="article-date">
  <time datetime="2015-08-27T11:17:24.000Z" itemprop="datePublished">2015-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/27/Poking-a-Hole-in-the-Patch/">Poking a Hole in the Patch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Escaping_from_IE_Sandbox_with_a_Poorly_Patched_Vulnerability">Escaping from IE Sandbox with a Poorly Patched Vulnerability</h2><p>Author: FlowerCode</p>
<h2 id="0x01_The_Problem">0x01 The Problem</h2><p>There was a privilege escalation vulnerability in Windows Audio Service, reported by James Forshaw in November 2014. </p>
<p>Windows Audio Service, which manages audio sessions of all the processes running in the system, store audio session configurations under register key HKCU\Software\Microsoft\Internet Explorer\LowRegistry\Audio\PolicyConfig.</p>
<p>For this configuration to be modifiable even by low privileged processes, it recursively set the sub key ACLs to give write access to Low IL processes.</p>
<p>If attacker set a symbolic link under this key, and point the symbolic link to a higher-privileged location, Windows Audio Service would make that location controllable by Low IL.</p>
<h2 id="0x02_The_Patch">0x02 The Patch</h2><p>Microsoft released a security bulletin MS14-071, followed by a patch KB3005607, in order to fix this vulnerability.<br>This patch added two functions, SafeRegCreateKeyEx and DetectRegistryLink.</p>
<p>The following is reconstructed DetectRegistryLink function:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DetectRegistryLink</span><span class="params">(<span class="keyword">const</span> HKEY key_handle, <span class="keyword">const</span> wchar_t sub_key_path[], HKEY * out_handle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> detect_result = <span class="number">0</span>;</span><br><span class="line">    HKEY sub_key_handle;</span><br><span class="line">    LSTATUS status = RegOpenKeyExW(key_handle,</span><br><span class="line">                                   sub_key_path,</span><br><span class="line">                                   REG_OPTION_OPEN_LINK,</span><br><span class="line">                                   KEY_ALL_ACCESS,</span><br><span class="line">                                   &amp;sub_key_handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == ERROR_FILE_NOT_FOUND) &#123;</span><br><span class="line">            detect_result = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == ERROR_ACCESS_DENIED) &#123;</span><br><span class="line">            detect_result = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            detect_result = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DWORD <span class="keyword">key_t</span>ype;</span><br><span class="line">        BYTE data[MAX_PATH * <span class="number">2</span>];</span><br><span class="line">        DWORD data_size = <span class="keyword">sizeof</span>(data);</span><br><span class="line"></span><br><span class="line">        status = RegQueryValueExW(sub_key_handle, </span><br><span class="line">                                  kSymbolicLinkValueName, </span><br><span class="line">                                  <span class="keyword">nullptr</span>,</span><br><span class="line">                                  &amp;<span class="keyword">key_t</span>ype, </span><br><span class="line">                                  data, </span><br><span class="line">                                  &amp;data_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) &amp;&amp; (<span class="keyword">key_t</span>ype == REG_LINK)) &#123;</span><br><span class="line">            detect_result = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> ((status == ERROR_FILE_NOT_FOUND) &amp;&amp; (detect_result != <span class="number">1</span>)) &#123;</span><br><span class="line">            HKEY temp_key_handle;</span><br><span class="line">            status = RegOpenKeyExW(key_handle,</span><br><span class="line">                                   sub_key_path,</span><br><span class="line">                                   <span class="number">0</span>,</span><br><span class="line">                                   KEY_READ,</span><br><span class="line">                                   &amp;temp_key_handle);</span><br><span class="line"></span><br><span class="line">            RegCloseKey(temp_key_handle);</span><br><span class="line">            detect_result = (status == ERROR_SUCCESS) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *out_handle = sub_key_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> detect_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DetectRegistryLink has strict check on symbolic links. It first opens the key with flag REG_OPTION_OPEN_LINK, which prevents the redirection, then check for many different cases, including redirection to non-existing keys. After performing all the checks, the key handle is passed out of the function for reuse.</p>
<p>The upper level function SafeRegCreateKeyEx use DetectRegistryLink to check the key for symbolic links before creating new sub key, use NtDeleteKey to delete the symbolic link (with the previously opened handle) if found any, and finally use RegCreateKeyEx to create a new, “safe to use” sub key.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">HKEY sub_key_handle;</span><br><span class="line"><span class="keyword">int</span> detect_result = DetectRegistryLink(key_handle, kSubKeyPath, &amp;sub_key_handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detect_result == <span class="number">1</span>) &#123;</span><br><span class="line">    status = NtDeleteKey(sub_key_handle);</span><br><span class="line">    RegCloseKey(sub_key_handle);</span><br><span class="line">    sub_key_handle = <span class="keyword">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detect_result &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub_key_handle) &#123;</span><br><span class="line">        RegCloseKey(sub_key_handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD create_disposition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sub_key_handle) &#123;</span><br><span class="line">    create_disposition = REG_OPENED_EXISTING_KEY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    status = RegCreateKeyExW(key_handle,</span><br><span class="line">                                kSubKeyPath,</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                <span class="keyword">nullptr</span>,</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                KEY_ALL_ACCESS,</span><br><span class="line">                                <span class="keyword">nullptr</span>,</span><br><span class="line">                                &amp;sub_key_handle,</span><br><span class="line">                                &amp;create_disposition);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_disposition != REG_CREATED_NEW_KEY) &#123;</span><br><span class="line">        RegCloseKey(sub_key_handle);</span><br><span class="line">        <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03_The_Flaw">0x03 The Flaw</h2><p>There is a serious flaw hidden inside this seemingly strict logic.</p>
<p>After NtDeleteKey deletes the symbolic link, the operating system no longer allow any additional operation to be performed on that key. The already opened handles remain valid, but any operation other than closing the key fails with STATUS_KEY_DELETED.</p>
<p>After the key handle is closed, the remaining operation must create a new key with a new handle. In this situation, the object with the same name is not guaranteed to be the same object.</p>
<p>With a precise timing attack, we could create a symbolic link just before the RegCreateKeyEx operation, bypassing the symbolic link check.</p>
<h2 id="0x04_The_Exploit">0x04 The Exploit</h2><p>We take IE 11 sandbox as an example to demonstrate how to escalate privilege with this vulnerability.</p>
<p>To exploit this vulnerability, we first need to make Windows Audio Service perform the delete operation.</p>
<p>We can purposely place a symbolic link under the HKCU\Software\Microsoft\Internet Explorer\LowRegistry\Audio\PolicyConfig registery key, and trigger Windows Audio Service to save its configuration.</p>
<p>It is vital to control the timing of the second symbolic link placement. Of course we could create millions of threads trying to win the race, but the operating system already provides us with a handy mechanism.</p>
<p>NtNotifyChangeKey can watch a specified registry key, and signal an event upon certain operation is performed on that key.</p>
<p>By setting a notification on our first symbolic link, we can receive a notification right after it is deleted by Windows Audio Service, and have a chance to create a second symbolic link just before Windows Audio Service calls RegCreateKeyEx.</p>
<p>We can then point the symbolic link to a non-existing GUID under HKCU\Software\Microsoft\Internet Explorer\Low Rights\ElevationPolicy to satisfy the REG_CREATED_NEW_KEY requirement. The target key will be created by Windows Audio Service.</p>
<p>Finally, Windows Audio Service will use upper level key (PolicyConfig)’s ACL to overwrite target key’s ACL, making it controllable by Low IL processes.</p>
<p>At this point the exploitation is successful. We can now write arbitrary AppPath and set Policy to 0x3 to escape from the sandbox.</p>
<h2 id="0x05_The_Trick">0x05 The Trick</h2><p>The registry operation performed by the Windows Audio Service is done after RpcImpersonateClient. Although the race can be successful inside IE sandbox, the registry operation will be performed with the originating process’ token, which do not have sufficient privilege.</p>
<p>James Forshaw did not solve this problem in the original PoC. The registry operation has to be performed by manually starting SndVol.exe.</p>
<p>To solve it we have to find a Medium or higher IL process that uses audio session, basically anything that emits sound, and can be repeatedly triggered to allow multiple retries.</p>
<p>IE Elevation Policy is preloaded with some system applications that can be started inside sandbox with Medium IL, including Notepad.exe. After the Medium IL process is started, the returned handle only have the right to terminate the process. But we can still pass command line parameters.</p>
<p>When Notepad is opening a non-existing file, it displays a dialog asking if the user would like to create that file. The dialog follows a default system sound. This is sufficient to trigger a registry write by Windows Audio Service.</p>
<p>With multiple retries we can ensure successful exploitation.</p>
<h2 id="0x06_The_Mitigation">0x06 The Mitigation</h2><p>Microsoft completely disabled the creation of registry symbolic link in a patch released in August 2015. When setting registry symbolic link, the kernel uses RtlIsSandboxToken to check the current process’s token, and return STATUS_ACCESS_DENIED on any Low IL or AppContainer token. This rendered any registry symbolic link based exploits unusable under Low IL, and effectively eliminates the possibility to exploit this vulnerability inside the IE sandbox.</p>
<h2 id="References">References</h2><ol>
<li>Issue 99:    IE11 AudioSrv RegistryKey EPM Privilege Escalation - James Forshaw<br><a href="https://code.google.com/p/google-security-research/issues/detail?id=99" target="_blank" rel="external">https://code.google.com/p/google-security-research/issues/detail?id=99</a></li>
<li>Vulnerability in Windows Audio Service Could Allow Elevation of Privilege (3005607)<br><a href="https://technet.microsoft.com/library/security/MS14-071" target="_blank" rel="external">https://technet.microsoft.com/library/security/MS14-071</a></li>
<li>Windows 10 Symbolic Link Mitigations - James Forshaw<br><a href="https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html" target="_blank" rel="external">https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/27/Poking-a-Hole-in-the-Patch/" data-id="cidv095zm0000msr9xpo86fm3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Research-report-on-using-JIT-to-trigger-RowHammer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/" class="article-date">
  <time datetime="2015-06-09T02:42:07.000Z" itemprop="datePublished">2015-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/">Research report on using JIT to trigger RowHammer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code><span class="attribute">Author</span>: <span class="string">R3dF09</span>
</code></pre><h1 id="0x00_Overview">0x00 Overview</h1><p>&emsp;&emsp;In a post published on Google Project Zero Blog, researchers explain that the RowHammer technique works by repeatedly accessing memory rows in DRAM to flip bits in adjacent rows. People worry about it because it need to update BIOS to fix this problem, it’s hard to solve. However it need to run the customized asm code on target machine to trigger RowHammer, so RowHammer is not easy to be used to attack.<br>&emsp;&emsp;We have an idea that try to use script language to trigger RowHammer. If it works, RowHammer will be more dangerous. In order to verify our idea, we analyzed the Java Hotspot, Chrome V8, .NET CoreCLR and Firefox SpiderMonfey.<br>&emsp;&emsp;Finally we didn’t find useful attack vector. Some of them don’t generate instructions needed to trigger RowHammer, some of them cannot trigger RowHammer due to small amount and slow speed of the instruction generation, some of them need environment modified to trigger so that we cannot use them to attack directly.   </p>
<h1 id="0x01_RowHammer">0x01 RowHammer</h1><p>&emsp;&emsp;In this section, we briefly review the root cause of RowHammer, how to trigger it and the limitation we will face with when trying to use it to attack.   </p>
<h2 id="1-1_What’s_RowHammer?">1.1 What’s RowHammer?</h2><p>&emsp;&emsp;RowHammer is a problem with some DDR3 in which repeatedly accessing a row of memory can cause bit flips in adjacent rows. As shown in Figure 1.1(a), DRAM comprises a two-dimensional array of DRAM cells. As shown in Figure 1.1(b), one cell consists of a capacitor and an access-transistor. The access-transistor connects to wordline and the capacitor stores the data. The data in a row can be accessible only if the wordline is in high voltage. The data in the row is transferred to row-buffer. When a wordline’s voltage toggle on and off repeatedly, some cells on nearby rows lose voltage. If it cannot retrain charge for even 64ms, this will lead to lose data.</p>
<p>&emsp;&emsp;Figure 1.2 shows a 2GB rank, whose 256K rows are vertically partitioned into eight banks of 32K rows, where each row is 8KB (64Kb). Each bank has its own dedicated row-buffer. Notice that accessing the rows in different bank is not able to trigger the RowHammer.<br><img src="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img1.png" alt="[Figure 1.1]" title="[Figure 1.1]"></p>
<center>Figure 1.1</center><br><img src="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img2.png" alt="[Figure 1.2]" title="[Figure 1.2]"><br><center>Figure 1.2</center>                    

<h2 id="1-2_Trigger_RowHammer">1.2 Trigger RowHammer</h2><p>&emsp;&emsp;Google Project Zero gives the snippet of code that can cause RowHammer.<br><img src="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img3.png" alt="img3.png" title=""><br>&emsp;&emsp;Address of X and Y is very important if you want to trigger RowHammer. X and Y must point to the same bank but different rows. Because each bank has its row-buffer and if we access the same row the wordline will not toggle on and off repeatedly. </p>
<p>&emsp;&emsp;This snippet of the code is available to trigger the RowHammer. But it isn’t the only one we can use. Notice that any code that can toggle the wordline can be used to trigger the RowHammer.</p>
<h2 id="1-3_Instruction_needed">1.3 Instruction needed</h2><p>&emsp;&emsp;In order to toggle the wordline on and off repeatedly, we have to deal with CPU Cache, if the address we want to access is already in Cache, the wordline will not be set to high voltage. </p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th style="text-align:center">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLFLUSH</td>
<td style="text-align:center">Flush the address form cache</td>
</tr>
<tr>
<td>PREFETCH</td>
<td style="text-align:center">Prefetch the data into the cache</td>
</tr>
<tr>
<td>MOVNT*</td>
<td style="text-align:center">Non-temporal memory access</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;The instructions above can be used to access some address and bypass the cache. So using these instructions we can toggle the wordline and trigger the RowHammer.  </p>
<h1 id="0x02_Using_Script_to_trigger_RowHammer">0x02 Using Script to trigger RowHammer</h1><p>&emsp;&emsp;The POC that Google Project Zero provides uses ASM code, it can be used to verify whether your devices are vulnerable. We know that most of the script languages have JIT compiler. If we can use the script to control the JIT compiler trigger RowHammer, the things will get worse. We research the Java Hotspot, Chrome V8, .Net CoreCLR and Firefox SpiderMonkey to verify the feasibility of our idea. </p>
<h2 id="2-1_Java_Hotspot">2.1 Java Hotspot</h2><p>&emsp;&emsp;The Java Hotspot Virtual Machine is a core component of the Java SE platform. It implements the Java Virtual Machine Specification. As the Java bytecode execution engine, it also includes dynamic compilers that adaptively compile Java bytecodes into optimized machine instructions. Hotspot is the Stack based virtual machine. The bytecodes are stored in the class file. As the input to hotspot, it is user controllable. What we care about is whether we can customize class file to make the Java Hotspot trigger the RowHammer.<br>&emsp;&emsp;When Java Hotspot runs Java bytecode, it continually analyzes the program’s performance for “hot spot” which are frequently or repeatedly executed. The JIT compiler would be used to compile these codes.<br>&emsp;&emsp;The default interpreter that comes with the Hotspot is the so called “Template Interpreter”. A second interpreter existed beside the template interpreter is a C++ interpreter its main interpreter loop is implemented in C++. The JIT compiler in Java Hotspot has three implementation, the client compiler (C1 Compiler), the server compiler (C2 Compiler) and the Shark Compiler ( LLVM based Compiler).<br><img src="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img4.png" alt="img4.png" title=""><br><img src="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img5.png" alt="img5.png" title="">  </p>
<center>Figure 2.1</center><br>### 2.1.1 Interpreter trigger RowHammer?<br>#### a) The working mechanism of template interpreter<br>&emsp;&emsp;The template interpreter is basically created at runtime from a kind of assembler templates which are translated into real machine code. It interprets a Java program by bytecode. When the interpreter gets a new bytecode, the corresponding native machine code would be called.<br>&emsp;&emsp;In order to interpret the Java program, Java Hotspot generates a lot of code stub when it starts such as StubRoutines::call_stub and StubRoutines::catch_exception. The command “java -XX:+PrintInterpterter” can be used to show the code stub that could be called in the interpret process.<br>&emsp;&emsp;Notice that the native machine code stub is a little big. For example, the code size of “invokevitual” is 352 bytes, and the code size of “putstatic” is 512 bytes.<br><br>#### b) Whether the interpreter can trigger RowHammer?<br>&emsp;&emsp;Whether we can customize the class file to make the Interpreter generate the machine code that we need to trigger the RowHammer. After analysis, we could not find the instructions such as prefetch, clflush and movnt<em> in the machine codes that generated in the interpreter. So we can’t use the template interpreter to trigger the RowHammer.<br><br>### 2.1.2 JIT Compiler trigger RowHammer?<br>#### a) The working mechanism of C1 Compiler<br>&emsp;&emsp;C1 Compiler is a fast, lightly optimizing bytecode compiler. It performs some value numbering, inlining, and class analysis. It uses a simple CFG-oriented SSA “high” IR, a machine-oriented “low” IR, a linear scan register allocation, and a template-style code generator.<br>&emsp;&emsp;The compiler is asynchronous, the “CompilerThread” thread in Hotspot compile the method that needed to be compiled. The command “-XX: +CompileThreshold” can be used to set the number of method invocations before compiling.<br><img src="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img6.png" alt="img6.png" title=""><br><center>Figure 2.2</center><br>&emsp;&emsp;In the source code of the hotspot,C1 Compiler has such phases:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  <span class="keyword">_t</span>_compile,</span><br><span class="line">  <span class="keyword">_t</span>_setup,</span><br><span class="line">  <span class="keyword">_t</span>_optimizeIR,</span><br><span class="line">  <span class="keyword">_t</span>_buildIR,</span><br><span class="line">  <span class="keyword">_t</span>_emit_lir,</span><br><span class="line">  <span class="keyword">_t</span>_linearScan,</span><br><span class="line">  <span class="keyword">_t</span>_lirGeneration,</span><br><span class="line">  <span class="keyword">_t</span>_lir_schedule,</span><br><span class="line">  <span class="keyword">_t</span>_codeemit,</span><br><span class="line">  <span class="keyword">_t</span>_codeinstall,</span><br><span class="line">  <span class="keyword">max_phase_t</span>imers</span><br><span class="line">&#125; TimerName;</span><br></pre></td></tr></table></figure><br><br>C1 Compiler can be briefly described as Figure 2.2 shows:<br>#### 1) Build HIR<br>&emsp;&emsp;C1 Compiler iterates the Java bytecodes in the class file and translates it into CFG (Control Flow Graph). The basic block of the CFG uses SSA to represent the instructions. HIR is a “high” IR far from machine code.<br>#### 2) Emit LIR<br>&emsp;&emsp;Iterate the basic blocks in the CFG, and iterate the instructions in the basic block. Translate the HIR to LIR. LIR is a “low” IR which is close to machine code.<br>#### 3) Register allocation<br>&emsp;&emsp;LIR uses many virtual register, in this phase, the compiler need to allocate the real register. The C1 Compiler uses the linear scan to allocate the register.<br>#### 4) Machine code generate<br>&emsp;&emsp;This is the phase to emit code, to genrate the real code. It iterates the instructions in the LIR to generate the machine code. The compile uses the LIR_Assembler class to finish this job, just as blow:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIR_Assembler lir_asm(<span class="keyword">this</span>);</span><br><span class="line">lir_asm.emit_code<span class="function"><span class="params">(hir()-&gt;code())</span>;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;The compiler iterates the LIR_list, invoke each instruction’s emit code. All instructions are the sub class of the LIR_Op. so they have “emit_code” method.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op-&gt;emit_code<span class="list">(<span class="keyword">this</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;Let’s see LIR_Op1, its “emit_code” method is:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LIR_Op1::emit_code(LIR_Assembler* masm) &#123;    <span class="comment">//emit_code</span></span><br><span class="line">  masm-&gt;emit_op1(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;If the Operand of the LIR_Op1 is “lir_prefetchr”<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">case</span> <span class="rule"><span class="attribute">lir_prefetchr</span>:<span class="value"></span><br><span class="line">  <span class="function">prefetchr</span>(op-&gt;<span class="function">in_opr</span>())</span></span>;</span><br><span class="line">  <span class="tag">break</span>;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;Then it will invoke the prefetchr function, it is platform-dependent, in x86, the code is in assembler_x86.cpp<br><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Assembler<span class="value">::<span class="function">prefetchr</span>(Address src) &#123;</span><br><span class="line">  <span class="function">assert</span>(VM_Version::<span class="function">supports_3dnow_prefetch</span>(), <span class="string">"must support"</span>);</span></span><br><span class="line">  InstructionMark <span class="function">im</span>(this);</span><br><span class="line">  <span class="function">prefetch_prefix</span>(src);</span><br><span class="line">  <span class="function">emit_byte</span>(0x0D);</span><br><span class="line">  <span class="function">emit_operand</span>(rax, src); <span class="comment">// 0, src</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;At last the compiler will generate the real executable machine code.<br><br>#### b)    Whether the C1 Compiler can trigger RowHammer<br>&emsp;&emsp;Whether the C1 Compiler can trigger RowHammer or not? We actually find the prefetch instruction in X86, it means we have hope to trigger RowHammer.<br>&emsp;&emsp;From bottom to top, if we want to get prefetch instruction, we need the LIR_Op1, and its openrand is lir_prefetchr or lir_prefetchw in LIR. To achieve this, we need to invoke the GraphBuilder::append_unsafe_prefetch function in HIR. The function is called by GraphBuilder::try_inline_instrinsics function. As last we found if we invoke the prefetch</em> method in sun.misc.Unsafe, we can get it. So the Hotspot does support prefetch. It treats Unsafe.prefetchRead() and Unsafe.prefetchWrite() methods as intrinsics. The method would generate prefetch instruction in the machine code. But unfortunately, sun.misc.Unsafe in rt.jar dose not declare such methods. We have to modify rt.jar to trigger that. What a pity!<br><br>&emsp;&emsp;In Hotspot, we also find the CLFLUSH instruction, when hotspot starts, it will generate a code stub<br><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__ bind<span class="list">(<span class="keyword">flush_line</span>)</span><span class="comment">;                         </span></span><br><span class="line">__ clflush<span class="list">(<span class="keyword">Address</span><span class="list">(<span class="keyword">addr</span>, <span class="number">0</span>)</span>)</span><span class="comment">;          //addr: address to flush </span></span><br><span class="line">__ addptr<span class="list">(<span class="keyword">addr</span>, ICache:<span class="keyword">:line_size</span>)</span><span class="comment">;                                         </span></span><br><span class="line">__ decrementl<span class="list">(<span class="keyword">lines</span>)</span><span class="comment">;                   //lines: range to flush</span></span><br><span class="line">__ jcc<span class="list">(<span class="keyword">Assembler</span>:<span class="keyword">:notZero</span>, flush_line)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>The code stub can be invoked in the last phase of C1 compiler.<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done</span></span><br><span class="line">masm<span class="comment">()</span>-&gt;flush<span class="comment">()</span>;             <span class="comment">//invoke ICache flush</span></span><br></pre></td></tr></table></figure><br>It try to flush the cache that instruction stored.<br><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">void</span> <span class="rule"><span class="attribute">AbstractAssembler</span>:<span class="value">:<span class="function">flush</span>() &#123;</span><br><span class="line">  <span class="function">sync</span>()</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">ICache</span>:<span class="value">:<span class="function">invalidate_range</span>(<span class="function">addr_at</span>(<span class="number">0</span>), <span class="function">offset</span>())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;Use this we can flush a range of address, but the problem is the address is uncontrollable, we cannot flush the address we wanted. And the compiler will spend much time, we cannot get enough CLFLUSH in 64ms.<br><br>#### c) Other Compiler<br>&emsp;&emsp;C2 Compiler is different from C1 Compiler. C2 Compiler is highly optimizing bytecode compiler. Optimizations include global value numbering, conditional constant type propagation, constant folding, and global code motion and so on. We cannot generate prefetch, clflush, movnt<em> instruction directly.<br>&emsp;&emsp;Shark Compiler is based on LLVM, we ignore it because it`s not the default compiler.<br><br>## 2.2 Chrome V8<br>&emsp;&emsp;The V8 JavaScript Engine is an open source JavaScript engine developed by Google Chrome web browser. V8 compiles JavaScript to native machine code before executing it. V8 does not have interpreter, it translates JavaScript to AST (Abstract Syntax Tree), then walks the AST to generate machine codes.<br>&emsp;&emsp;After research, we did not find clflush, movnt</em> instructions when V8 compile the JavaScript. We found prefetch instruction in a function.<br>&emsp;&emsp;The function that generate prefetch is:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MemMoveFunction CreateMemMoveFunction<span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  __ prefetch<span class="params">(Operand<span class="params">(src, <span class="number">0</span>)</span>, <span class="number">1</span>)</span>;</span><br><span class="line">  __ cmp<span class="params">(count, kSmallCopySize)</span>;    <span class="comment">//kSmallCopySize=8</span></span><br><span class="line">  __ j<span class="params">(below_equal, &amp;small_size)</span>;  </span><br><span class="line">  __ cmp<span class="params">(count, kMediumCopySize)</span>;   <span class="comment">//kMediumCopySize=63</span></span><br><span class="line">  __ j<span class="params">(below_equal, &amp;medium_size)</span>;</span><br><span class="line">  __ cmp<span class="params">(dst, src)</span>;</span><br><span class="line">  __ j<span class="params">(above, &amp;backward)</span>;</span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;This function is used to move memory, when the instruction buffer is not big enough to store the compiled code. V8 has to enlarge the buffer, at this time the instruction can be generated one time. It cannot be used to trigger RowHammer.<br><br>## 2.3 .NET CoreCLIR<br>&emsp;&emsp;CoreCLR is the .NET Core Runtime. It includes RyuJIT, the .NET GC and many other components. RyuJIT is the JIT compiler in .NET CoreCLR. RyuJIT only defines some common x86 instructions (Figure 2.3) that do not include the instruction needed to trigger RowHammer.<br>&emsp;&emsp;We found the prefetch instruction in .NET GC component, just as shown in Figure2.4 But unfortunately the prefetch is disable by default (Figure 2.5).<br><img src="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img7.png" alt="img7.png" title=""><br><center>Figure 2.3</center><br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void gc_heap<span class="number">::</span>relocate_survivor_helper (BYTE* plug, BYTE* plug_end)</span><br><span class="line">&#123;</span><br><span class="line">    BYTE*  x = plug<span class="comment">;</span></span><br><span class="line">    while (x &lt; plug_end)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t s = size (x)<span class="comment">;</span></span><br><span class="line">        BYTE* next_obj = x + Align (s)<span class="comment">;</span></span><br><span class="line">        Prefetch (next_obj)<span class="comment">;</span></span><br><span class="line">        relocate_obj_helper (x, s)<span class="comment">;</span></span><br><span class="line">        assert (s &gt; 0)<span class="comment">;</span></span><br><span class="line">        x = next_obj<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center>Figure 2.4</center>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define PREFETCH</span></span><br><span class="line"><span class="preprocessor">#ifdef PREFETCH</span></span><br><span class="line">__declspec(naked) <span class="keyword">void</span> __<span class="function">fastcall <span class="title">Prefetch</span><span class="params">(<span class="keyword">void</span>* addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   __asm &#123;</span><br><span class="line">       PREFETCHT0 [ECX]</span><br><span class="line">        ret</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span> <span class="comment">//PREFETCH</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prefetch</span> <span class="params">(<span class="keyword">void</span>* addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">//PREFETCH</span></span></span><br></pre></td></tr></table></figure>
<center>Figure 2.5</center>

<h2 id="2-4_Firfox_SpiderMonkey">2.4 Firfox SpiderMonkey</h2><p>&emsp;&emsp;SpiderMonkey provides JavaScript support for Mozilla Firefox, we didn’t find the instructions needed to trigger RowHammer in it.</p>
<h1 id="0x03_Conclusion">0x03 Conclusion</h1><p>&emsp;&emsp;The purpose of our research is to trigger RowHammer through script languages. In order to improve the efficiency of the language, most of them has JIT compiler. We analyzed Hotspot, Chrome V8, .NET CoreCLR and SpiderMonkey to try to verify our idea. But finally we found it is hard to get what we want.</p>
<p>1) Trigger RowHammer is not easy, we only have 64ms. It means the number of irrelevant instructions must be very few. Otherwise the number of the wordline toggle on and off is not enough to trigger RowHammer. </p>
<p>2) The instruction we need is uncommon. The compiler does not generate these instructions directly.</p>
<p>3) In the view of JIT compiler developers, in order to cross-platform, JIT usually abstracts the instruction, and implements it on different platforms. So the abstracted instruction is as few as possible. Because more instructions means much more codes. In the source code we analyzed, only hotspot abstracts the prefetch instruction. JIT compiler always try to avoid a lot of instruction definitions. (There are some special cases where script languages use third-party JIT engine such as AsmJIT, the engine usually supports all instructions. But for now, most languages always build JIT dependently).</p>
<p>4) In our research, we found the instruction we need always generated to assistance JIT compile process. For example, using prefetch to increase the speed of data move, using clflush to flash cache to assure the execution of the code generated. Instructions are not translated from script directly, the RowHammer problem cannot be triggered due to the small amount and slow speed of the instruction generation.</p>
<h1 id="Resources">Resources</h1><ol>
<li>Google Project Zero<br><a href="http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" target="_blank" rel="external">http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html</a></li>
<li>Paper: Flipping Bits in Memory Without Accessing Them: An Experimental Study of DRAM Disturbance Errors  <a href="http://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf" target="_blank" rel="external">http://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf</a></li>
<li>Source code</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/" data-id="cidv096000001msr9ugit9w5h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/08/27/Poking-a-Hole-in-the-Patch/">Poking a Hole in the Patch</a>
          </li>
        
          <li>
            <a href="/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/">Research report on using JIT to trigger RowHammer</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 XuanwuTeam<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>